# LestaGamesTestTask

## Вопрос №1

<details> 
  <summary>Задание</summary>
  На языке Python написать алгоритм (функцию) определения четности целого числа, который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути. Объяснить плюсы и минусы обеих реализаций. 

Пример: 
```
def isEven(value):
  return value % 2 == 0
```
</details>

[Task1.py](https://github.com/HeatherPurple/LestaGamesTestTask/blob/main/Task1.py)

Реализация с использованием "value & 1" является более эффективной с точки зрения производительности, однако же вариант "value % 2" проще для понимания. В зависимости от контекста, следует выбирать тот или иной вариант - в угоду эффективности или читабельности кода.

------

## Вопрос №2

<details> 
  <summary>Задание</summary>
  На языке Python написать минимум по 2 класса реализовывающих циклический буфер FIFO. Объяснить плюсы и минусы каждой реализации.

Оценивается:

* Полнота и качество реализации
* Оформление кода
* Наличие сравнения и пояснения по быстродействию
</details>

[Task2.1.py](https://github.com/HeatherPurple/LestaGamesTestTask/blob/main/Task2.1.py)

[Task2.2.py](https://github.com/HeatherPurple/LestaGamesTestTask/blob/main/Task2.2.py)

Первый вариант представляет из себя использование статического массива и индексы. Второй вариант представляет из себя связный список. Здесь каждый элемент помимо информации содержит ссылку на следующий.

В данном случае к плюсам первой реализации стоит отнести более эффективное использование памяти, поскольку не требуется дополнительно хранить связи между элементами. 
Во второй реализации размер буфера, в свою очередь, может быть легко изменен, что делает его более гибким в использовании. Динамически изменять можно и первый буфер, однако тогда будет создаваться новый массив, в который будут перемещены все элементы.

Таким образом, если размер буфера будет изменяться, целесообразно использовать второй вариант. Однако при неизменности размера буфера статический массив будет предпочтительней.


------

## Вопрос №3

<details> 
  <summary>Задание</summary>
  На языке Python предложить алгоритм, который быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел. Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным). Объяснить, почему вы считаете, что функция соответствует заданным критериям.
</details>

[Task3.py](https://github.com/HeatherPurple/LestaGamesTestTask/blob/main/Task3.py)

Для быстрой сортировки часто используется сортировка Хоара. Она имеет сложность О(N*logN) в лучшем случае и О(N^2) в худшем, однако на практике часто демонстрирует среднюю сложность О(N*logN).
Пусть в среднем случае она имеет такую же сложность, как и, например, сортировка слиянием, на практике она часто работает быстрее засчет меньшего количества перестановок и использованиям дополнительной памяти.

При выборе алгоритма также следует учитывать входные данные. Так, на малых данных можно использовать сортировку слиянием или вставками, но на больших данных они могут показывать себя значительно хуже. 
Также не стоит забывать и про особенности тех или иных сортировок. Timsort, например, имеет высокую скорость работы на частично отсортированных данных. А некоторые алгоритмы являются неустойчивыми, 
что может быть неприемлемо при сортировке больших объектов.

Таким образом, поскольку в данном случае мы имеем массив чисел, и важна производительность, то быстрая сортировка вполне подойдет.

------
